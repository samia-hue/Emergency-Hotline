
1) var, let, ‡¶Ü‡¶∞ const ‡¶è‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶™‡¶æ‡¶∞‡ßç‡¶•‡¶ï‡ßç‡¶Ø

var

Function scope ‡¶è ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá‡•§

‡¶è‡¶ï‡¶á ‡¶®‡¶æ‡¶Æ‡ßá‡¶∞ ‡¶≠‡ßá‡¶∞‡¶ø‡¶Ø‡¶º‡ßá‡¶¨‡¶≤ ‡¶Ü‡¶¨‡¶æ‡¶∞ declare ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü‡•§

Hoisting ‡¶π‡ßü (‡¶Æ‡¶æ‡¶®‡ßá ‡¶°‡¶ø‡¶ï‡ßç‡¶≤‡ßá‡ßü‡¶æ‡¶∞‡ßá‡¶∂‡¶®‡ßá‡¶∞ ‡¶Ü‡¶ó‡ßá ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶Æ‡¶æ‡¶® ‡¶π‡¶¨‡ßá undefined)‡•§

‡¶Ö‡¶®‡ßá‡¶ï ‡¶¨‡¶æ‡¶ó ‡¶∏‡ßÉ‡¶∑‡ßç‡¶ü‡¶ø ‡¶ï‡¶∞‡ßá ‡¶§‡¶æ‡¶á ‡¶è‡¶ñ‡¶® ‡¶ñ‡ßÅ‡¶¨ ‡¶ï‡¶Æ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡•§

let

Block scope ‡¶è ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá (‡¶Ø‡ßá‡¶Æ‡¶® { } ‡¶è‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ scope)‡•§

‡¶è‡¶ï‡¶á scope ‡¶è ‡¶è‡¶ï‡¶á ‡¶®‡¶æ‡¶Æ ‡¶¶‡¶ø‡ßü‡ßá ‡¶Ü‡¶¨‡¶æ‡¶∞ declare ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü ‡¶®‡¶æ‡•§

Hoisting ‡¶π‡ßü, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶°‡¶ø‡¶ï‡ßç‡¶≤‡ßá‡ßü‡¶æ‡¶∞‡ßá‡¶∂‡¶®‡ßá‡¶∞ ‡¶Ü‡¶ó‡ßá ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü ‡¶®‡¶æ (temporal dead zone error ‡¶¶‡¶ø‡¶¨‡ßá)‡•§

const

Block scope ‡¶è ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá‡•§

‡¶Æ‡¶æ‡¶® ‡¶è‡¶ï‡¶¨‡¶æ‡¶∞ assign ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶™‡¶∞ ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü ‡¶®‡¶æ (immutable)‡•§

‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶Ø‡¶¶‡¶ø object ‡¶¨‡¶æ array ‡¶π‡ßü ‡¶§‡¶¨‡ßá ‡¶≠‡ßá‡¶§‡¶∞‡ßá‡¶∞ value ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü‡•§

2) map(), forEach(), ‡¶Ü‡¶∞ filter() ‡¶è‡¶∞ ‡¶™‡¶æ‡¶∞‡ßç‡¶•‡¶ï‡ßç‡¶Ø

forEach()

‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø element ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶è‡¶ï‡¶ü‡¶ø callback ‡¶ö‡¶æ‡¶≤‡¶æ‡ßü‡•§

return ‡¶ï‡¶∞‡ßá ‡¶®‡¶æ ‡¶ï‡¶ø‡¶õ‡ßÅ, ‡¶∂‡ßÅ‡¶ß‡ßÅ ‡¶ï‡¶æ‡¶ú ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶® ‡¶ï‡¶∞‡ßá‡•§

‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£‡¶§ data loop ‡¶ï‡¶∞‡ßá ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø‡•§

map()

‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø element ‡¶è‡¶∞ ‡¶â‡¶™‡¶∞ callback ‡¶ö‡¶æ‡¶≤‡¶æ‡ßü‡•§

‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø element ‡¶è‡¶∞ result ‡¶®‡¶ø‡ßü‡ßá ‡¶®‡¶§‡ßÅ‡¶® ‡¶è‡¶ï‡¶ü‡¶ø array return ‡¶ï‡¶∞‡ßá‡•§

‡¶Ø‡¶ñ‡¶® data ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶ï‡¶∞‡ßá ‡¶®‡¶§‡ßÅ‡¶® array ‡¶¨‡¶æ‡¶®‡¶æ‡¶§‡ßá ‡¶π‡ßü ‡¶§‡¶ñ‡¶® ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡•§

filter()

‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø element ‡¶è‡¶∞ ‡¶â‡¶™‡¶∞ ‡¶∂‡¶∞‡ßç‡¶§ ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡ßá‡•§

‡¶Ø‡ßá‡¶ó‡ßÅ‡¶≤‡ßã condition ‡¶™‡ßÇ‡¶∞‡¶£ ‡¶ï‡¶∞‡ßá ‡¶∂‡ßÅ‡¶ß‡ßÅ ‡¶∏‡ßá‡¶ó‡ßÅ‡¶≤‡ßã ‡¶®‡¶ø‡ßü‡ßá ‡¶®‡¶§‡ßÅ‡¶® ‡¶è‡¶ï‡¶ü‡¶ø array return ‡¶ï‡¶∞‡ßá‡•§

3) Arrow Functions (ES6)

Arrow function ‡¶π‡¶≤‡ßã function ‡¶≤‡ßá‡¶ñ‡¶æ‡¶∞ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡¶ø‡¶™‡ßç‡¶§ syntax‡•§

Example:

const add = (a, b) => a + b;


‡¶¨‡ßà‡¶∂‡¶ø‡¶∑‡ßç‡¶ü‡ßç‡¶Ø:

‡¶õ‡ßã‡¶ü syntax, ‡¶ï‡¶Æ ‡¶ï‡ßã‡¶° ‡¶≤‡¶æ‡¶ó‡ßá‡•§

‡¶®‡¶ø‡¶ú‡ßá‡¶∞ this bind ‡¶ï‡¶∞‡ßá ‡¶®‡¶æ, parent scope ‡¶è‡¶∞ this ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá‡•§

Constructor function ‡¶π‡¶ø‡¶∏‡ßá‡¶¨‡ßá ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü ‡¶®‡¶æ‡•§

4) Destructuring Assignment (ES6)

Destructuring ‡¶Æ‡¶æ‡¶®‡ßá ‡¶π‡¶≤‡ßã object ‡¶¨‡¶æ array ‡¶•‡ßá‡¶ï‡ßá value ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ ‡¶ï‡¶∞‡ßá ‡¶∏‡¶π‡¶ú‡¶≠‡¶æ‡¶¨‡ßá ‡¶¨‡ßá‡¶∞ ‡¶ï‡¶∞‡¶æ‡•§

Example (array):

const numbers = [10, 20, 30];
const [a, b, c] = numbers; 
// a=10, b=20, c=30


Example (object):

const user = {name: "Rahim", age: 22};
const {name, age} = user;
// name="Rahim", age=22

5) Template Literals (ES6)

Template literals ‡¶Æ‡¶æ‡¶®‡ßá ‡¶π‡¶≤‡ßã backtick (`) ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶ø‡¶Ç ‡¶≤‡ßá‡¶ñ‡¶æ‡•§

‡¶è‡¶∞ ‡¶≠‡ßá‡¶§‡¶∞‡ßá ${} ‡¶¶‡¶ø‡ßü‡ßá variable ‡¶¨‡¶æ expression ‡¶¨‡¶∏‡¶æ‡¶®‡ßã ‡¶Ø‡¶æ‡ßü‡•§

Example:

const name = "Rahim";
const age = 22;
console.log(`My name is ${name} and I am ${age} years old.`);


üëâ ‡¶™‡¶æ‡¶∞‡ßç‡¶•‡¶ï‡ßç‡¶Ø string concatenation ‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá:

‡¶Ü‡¶ó‡ßá ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡¶§‡ßã:

"My name is " + name + " and I am " + age + " years old.";


Template literals ‡¶è ‡¶∏‡¶π‡¶ú‡ßá ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡ßü, ‡¶∏‡¶æ‡¶•‡ßá multi-line string ‡¶ì ‡¶≤‡ßá‡¶ñ‡¶æ ‡¶Ø‡¶æ‡ßü‡•§